---
title: 结构体_联合体
author: chuiyu
date: 2026-02-05 08:00:00
description: 标题
tags:
  - Cpp_base
permalink: /pages/d78cc9
categories:
  - guide
  - C++基础
---


# 结构体
**结构体**（struct），可以看做是一系列称为成员元素的组合体．

可以看做是自定义的数据类型．

> [!NOTE]
> 本页描述的 `struct` 不同于 C 中 `struct`，在 C++ 中 `struct` 被扩展为类似 [`class`](https://oi-wiki.org/lang/class/) 的类说明符．


## 定义结构体
```cpp
struct Object {
  int weight;
  int value;
} e[array_length];

const Object a;
Object b, B[array_length], tmp;
Object *c;
```

上例中定义了一个名为 `Object` 的结构体，两个成员元素 `value, weight`，类型都为 `int`．

在 `}` 后，定义了数据类型为 `Object` 的常量 `a`，变量 `b`，变量 `tmp`，数组 `B`，指针 `c`．对于某种已经存在的类型，都可以使用这里的方法进行定义常量、变量、指针、数组等．

_关于指针：不必强求掌握．_

### 定义指针

如果是定义内置类型的指针，则与平常定义指针一样．

如果是定义结构体指针，在定义中使用 `StructName*` 进行定义．

```cpp
struct Edge { 
/* ... */ 
Edge* nxt; 
};
```

上例仅作举例，不必纠结实际意义．

## 访问/修改成员元素

可以使用 `变量名.成员元素名` 进行访问．例如可以使用 `cout << var.v` 来输出 `var` 的 `v` 成员．

也可以使用 `指针名->成员元素名` 或者 使用 `(*指针名).成员元素名` 进行访问．例如使用 `(*ptr).v = tmp` 或者 `ptr->v = tmp` 可以将结构体指针 `ptr` 指向的结构体的成员元素 `v` 赋值为 `tmp`：．


### 代码实战

例程代码：
```cpp
#include <iostream>
#include <memory>
#include <string>

struct CameraConfig {
    std::string device_path;
    int fps;
    
    void PrintInfo() const {
        std::cout << "Device: " << device_path << " @ " << fps << "fps\n";
    }
};

int main() {
    // 1. 栈分配：最快，自动释放（推荐用于局部小对象）
    CameraConfig config_obj{"/dev/video0", 30};
    config_obj.fps = 60; // 方式 A：. 访问

    // 2. 智能指针分配：堆内存安全（推荐用于大对象或长生命周期对象）
    // 使用 std::make_unique 替代 new
    auto smart_cfg = std::make_unique<CameraConfig>("/dev/video1", 25);
    
    smart_cfg->fps = 30;         // 方式 B：-> 访问（最常用）
    (*smart_cfg).fps = 30;       // 方式 C：解引用后访问（效果等同 B，但冗余）

    // 3. 结构化绑定 (C++17 特性)：工程实战利器
    auto [path, rate] = config_obj; 
    std::cout << "Path: " << path << "\n";

    return 0;
}
```

```bash
g++ test.cpp -lm -std=c++17
```

> [!NOTE]
> ### 底层/顶层原理解析
> 
> #### 1. 底层视角 (The C Way)
> 
> - **`.` (点操作符)**：偏移量寻址。编译器知道 `fps` 距离结构体首地址有多少字节（偏移量），直接操作 `base_addr + offset`。
>     
> - **`->` (箭头操作符)**：**解引用 + 偏移**。`ptr->fps` 实际上是 `(*ptr).fps` 的语法糖。底层执行了两步：
>     
>     1. 从寄存器读取指针存储的地址。
>         
>     2. 跳转到该地址并根据偏移量找到成员。
>         
> - **嵌入式注意点**：在 RK3588 等平台上，频繁通过 `->` 访问分散在堆上的小对象会导致 **Cache Miss**。我们更倾向于 RAII 形式的栈分配或连续内存池。
>     
> 
> #### 2. 顶层视角 (The Python Way)
> 
> - `config_obj.fps` 就等同于 Python 里的 `obj.fps`。
>     
> - `smart_cfg->fps` 类似于 Python 中处理一个**被封装过的引用**。在 Python 里你感知不到指针，但在 C++ 中，`unique_ptr` 就像是一个自带“自动销毁触发器”的引用。当 `smart_cfg` 离开作用域，它会自动调用 Python 垃圾回收般的清理动作，但这是在**编译期**决定的，没有 GC 开销。
>     
> 
> #### 3. 工程实战 (The Embedded Way)
> 
> 在处理 **OpenCV Mat** 或 **RKNN Tensor** 时：
> 
> - **Zero-Copy (零拷贝)**：当你传递 `CameraConfig&` (引用) 或 `std::unique_ptr` 时，你只是传递了地址，没有像 Python 那样产生深拷贝。
>     
> - **成员访问性能**：
>     
>     - 直接访问 `obj.member`：编译器能做极致优化（甚至内联）。
>         
>     - 通过指针 `ptr->member`：如果指针是 `nullptr`，直接 OOM 或 Segfault。
>         
>     - **架构师寄语**：在 C++11 之后，如果你发现自己在写 `*` 或 `->`，先问自己一句：**这个对象能不能直接放栈上用引用传递？**
>         
> 
> ### 💡 总结笔记：
> 
> - **`obj.field`**：我有这个东西，我直接用它。
>     
> - **`ptr->field`**：我知道那个东西在哪，我远程控制它。
>     
> - **`(*ptr).field`**：我先把那个东西抓过来，再用它（通常只在重载操作符时出现，平时少写，显累）。

### 为什么需要结构体？
首先，条条大路通罗马，可以不使用结构体达到相同的效果．但是结构体能够显式地将成员元素（在算法竞赛中通常是变量）捆绑在一起，如本例中的 Object 结构体，便将 value,weight 放在了一起（定义这个结构体的实际意义是表示一件物品的重量与价值）．这样的好处边是限制了成员元素的使用．
想象一下，如果不使用结构体而且有两个数组 value[ ], Value[ ]，很容易写混淆．但如果使用结构体，能够减轻出现使用变量错误的几率．

并且不同的结构体（结构体类型，如 Object 这个结构体）或者不同的结构体变量（结构体的实例，如上方的 e 数组）可以拥有相同名字的成员元素（如 tmp.value,b.value），同名的成员元素相互独立（拥有独自的内存，比如说修改 tmp.value 不会影响 b.value 的值）．
这样的好处是可以使用尽可能相同或者相近的变量去描述一个物品．比如说 Object 里有 value 这个成员变量；我们还可以定义一个 Car 结构体，同时也拥有 value 这个成员；如果不使用结构体，或许我们就需要定义 valueOfObject[],valueOfCar[] 等不同名称的数组来区分．


# 联合体
**联合体**（union）是特殊的类类型，它在一个时刻只能保有其一个非静态数据成员．

联合体在 2023 年正式被加入 NOI 大纲入门级中．

## 定义联合体

联合体声明的类说明符与类或 [结构体](https://oi-wiki.org/lang/struct/) 的声明相似：

```cpp
union MyUnion 
{
   int x;
   long long y; 
} x;
```

联合体的定义与结构体类似．按照上述定义，`MyUnion` 同样可以当作一种自定义类型使用．名称 `MyUnion` 可以省略．

## 访问/修改成员元素

与结构体类似，同样可以使用 `变量名.成员名` 进行访问．

联合体所占用的内存空间大小 **不小于** 其最大的成员的大小，所有成员 **共用内存空间与地址**．当一个成员被赋值，由于内存共享，该联合体中的其他成员都会被覆盖．即同一时刻联合体中只能保存一个成员的值．

联合体的更多用法可以参见 [cppreference：联合体声明](https://zh.cppreference.com/w/cpp/language/union)．


