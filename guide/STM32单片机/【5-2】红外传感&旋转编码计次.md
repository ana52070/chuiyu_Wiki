---
author: chuiyu
date: 2026-02-04
description: 【5-2】红外传感&旋转编码计次
tags:
- STM32单片机
---

# 【5-2】红外传感&旋转编码计次

## 红外传感

**对射式红外传感器计次**



### 接线图

![image-20231128172315191](assets/image-20231128172315191.png)

### 程序实例

**CountSensor.h**

```c
#ifndef __COUNT_SENSOR_H
#define __COUNT_SENSOR_H

void CountSensor_Init(void);
uint16_t CountSonsor_Get(void);
//中断函数不用声明，因为中断函数不需要调用，它是自动执行的

#endif 

```



**CountSensor.c**

```c
#include "stm32f10x.h"                  // Device header


uint16_t CountSonsor_Count;

void CountSensor_Init(void)
{
	//进行外部中断的配置
	//开启GPIOB的时钟	(注意GPIOB是APB2的外设)
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);
	
	//开启AFIO的时钟，AFIO也是APB2的外设
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);
	
	//EXTI和NVIC这两个外设的时钟是一直开着的所以我们不需要自己开启。
	
	//配置GPIO：
	
	GPIO_InitTypeDef GPIO_InitStructrue;	//定义结构体
	GPIO_InitStructrue.GPIO_Mode = GPIO_Mode_IPU;	//上拉输入，默认为高电平
	GPIO_InitStructrue.GPIO_Pin = GPIO_Pin_14;
	GPIO_InitStructrue.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOB,&GPIO_InitStructrue);//GPIO初始化
	
	//配置AFIO
	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB,GPIO_PinSource14);
	
	EXTI_InitTypeDef EXTI_InitStruct;	//定义结构体，用于EXTI的初始化
	EXTI_InitStruct.EXTI_Line = EXTI_Line14;	//指定要配置的中断线
	EXTI_InitStruct.EXTI_LineCmd = ENABLE;	//指定选择的中断线的新状态
	EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;//中断模式
	EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Falling;//下降沿触发
	
	//EXTI初始化
	EXTI_Init(&EXTI_InitStruct);
	
	//NVIC分组
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
	
	NVIC_InitTypeDef NVIC_InitStruct;//定义结构体，用于NVIC的初始化
	NVIC_InitStruct.NVIC_IRQChannel = EXTI15_10_IRQn;//指定中断通道来开启或关闭
	NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;//指定中断通道是使能(或者失能DISABLE)
	NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 1;//指定抢占优先级
	NVIC_InitStruct.NVIC_IRQChannelSubPriority = 1;	//指定响应优先级
	//NVIC初始化
	NVIC_Init(&NVIC_InitStruct);
}

uint16_t CountSonsor_Get(void)
{
	return CountSonsor_Count;
}


//中断函数不用声明，因为中断函数不需要调用，它是自动执行的
void EXTI15_10_IRQHandler(void)
{
	//标志位判断
	//因为进来此中断函数的是10-15脚，不一定就是14脚，所以要进行标志位判断
	if (SET == EXTI_GetFlagStatus(EXTI_Line14))
	{
		CountSonsor_Count++;
		
		//清除标志位，以防止程序一直申请中断，一直都在中断函数中卡死
		EXTI_ClearITPendingBit(EXTI_Line14);
	}
}

```



**main.c**

```c
#include "stm32f10x.h"                  // Device header
#include "Delay.h"
#include "OLED.h"
#include "CountSensor.h"

int main(void)
{
	/*模块初始化*/
	OLED_Init();		//OLED初始化
	CountSensor_Init();
	
	OLED_ShowString(1, 1, "Count:");	//1行3列显示字符串HelloWorld!
	

	
	while (1)
	{
		OLED_ShowNum(1,7,CountSonsor_Get(),5);
	}
}

```





## 旋转编码计次



### 接线图

![image-20231128185838732](assets/image-20231128185838732-1701169120076-1.png)



### 程序实例

**Encoder.h**

```c
#ifndef __ENCODER_H
#define __ENCODER_H

void Encoder_Init(void);
int16_t Encoder_Get(void);


#endif

```

**Encoder.c**

```c
#include "stm32f10x.h"                  // Device header


int16_t Encoder_Count;

void Encoder_Init(void)
{
	//进行外部中断的配置
	//开启GPIOB的时钟	(注意GPIOB是APB2的外设)
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);
	
	//开启AFIO的时钟，AFIO也是APB2的外设
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);
	
	//EXTI和NVIC这两个外设的时钟是一直开着的所以我们不需要自己开启。
	
	//配置GPIO：
	
	GPIO_InitTypeDef GPIO_InitStructrue;	//定义结构体
	GPIO_InitStructrue.GPIO_Mode = GPIO_Mode_IPU;	//上拉输入，默认为高电平
	GPIO_InitStructrue.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1;
	GPIO_InitStructrue.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOB,&GPIO_InitStructrue);//GPIO初始化
	
	//配置AFIO
	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB,GPIO_PinSource0);
	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB,GPIO_PinSource1);
	
	EXTI_InitTypeDef EXTI_InitStruct;	//定义结构体，用于EXTI的初始化
	EXTI_InitStruct.EXTI_Line = EXTI_Line0 | EXTI_Line1;	//指定要配置的中断线
	EXTI_InitStruct.EXTI_LineCmd = ENABLE;	//指定选择的中断线的新状态
	EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;//中断模式
	EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Falling;//下降沿触发
	
	//EXTI初始化
	EXTI_Init(&EXTI_InitStruct);
	
	//NVIC分组
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
	
	NVIC_InitTypeDef NVIC_InitStruct;//定义结构体，用于NVIC的初始化
	NVIC_InitStruct.NVIC_IRQChannel = EXTI0_IRQn;//指定中断通道来开启或关闭
	NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;//指定中断通道是使能(或者失能DISABLE)
	NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 1;//指定抢占优先级
	NVIC_InitStruct.NVIC_IRQChannelSubPriority = 1;	//指定响应优先级
	//NVIC初始化
	NVIC_Init(&NVIC_InitStruct);
	
	
	NVIC_InitStruct.NVIC_IRQChannel = EXTI1_IRQn;//指定中断通道来开启或关闭
	NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;//指定中断通道是使能(或者失能DISABLE)
	NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 1;//指定抢占优先级
	NVIC_InitStruct.NVIC_IRQChannelSubPriority = 2;	//指定响应优先级
	//NVIC初始化
	NVIC_Init(&NVIC_InitStruct);
}


int16_t Encoder_Get(void)
{
	int16_t Temp;
	Temp = Encoder_Count;
	Encoder_Count = 0;
	return Temp;
}

void EXTI0_IRQHandler(void)
{
	//判断标志位
	if (EXTI_GetFlagStatus(EXTI_Line0) == SET)
	{
		//判断是否为反转
		if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_1) == 0)
		{
			Encoder_Count--;
		}
		//清除标志位
		EXTI_ClearITPendingBit(EXTI_Line0);
	}
	
}

void EXTI1_IRQHandler(void)
{
	//判断标志位
	if (EXTI_GetFlagStatus(EXTI_Line1) == SET)
	{
		//判断是否为正转
		if(GPIO_ReadOutputDataBit(GPIOB,GPIO_Pin_1) == 0)
		{
			Encoder_Count++;
		}
		//清除标志位
		EXTI_ClearITPendingBit(EXTI_Line1);
	}
}

```



**main.c**

```c
#include "stm32f10x.h"                  // Device header
#include "Delay.h"
#include "OLED.h"
#include "Encoder.h"

uint16_t Num;
int main(void)
{
	/*模块初始化*/
	OLED_Init();		//OLED初始化
	Encoder_Init();
	
	/*OLED显示*/
	
	OLED_ShowString(1, 1, "Num:");	//1行3列显示字符串HelloWorld!

	
	while (1)
	{
		Num += Encoder_Get();
		OLED_ShowSignedNum(1,5,Num,5);
	}
}

```





