---
title: 第二章 语言可用性的强化
author: chuiyu
date: 2026-02-05 08:00:00
description: 第二章 语言可用性的强化
tags:
  - Cpp17
permalink: /pages/88f080
categories:
  - guide
  - C++17
---
# 第二章 语言可用性的强化

当我们声明、定义一个变量或者常量，对代码进行流程控制、面向对象的功能、模板编程等这些都是运行时之前，可能发生在编写代码或编译器编译代码时的行为。为此，我们通常谈及**语言可用性**，是指那些发生在运行时之前的语言行为。




## 2.1 常量

### nullptr

`nullptr` 出现的目的是为了替代 `NULL`。 C 与 C++ 语言中有**空指针常量**，它们能被隐式转换成任何指针类型的空指针值，或 C++ 中的任何成员指针类型的空成员指针值。 `NULL` 由标准库实现提供，并被定义为实现定义的空指针常量。在 C 中，有些标准库会把 `NULL` 定义为 `((void*)0)` 而有些将它定义为 `0`。

C++ **不允许**直接将 `void *` 隐式转换到其他类型，从而 `((void*)0)` 不是 `NULL` 的合法实现。如果标准库尝试把 `NULL` 定义为 `((void*)0)`，那么下面这句代码中会出现编译错误：

```cpp
char *ch = NULL;
```

没有了 `void *` 隐式转换的 C++ 只好将 `NULL` 定义为 `0`。而这依然会产生新的问题，将 `NULL` 定义成 `0` 将导致 `C++` 中重载特性发生混乱。考虑下面这两个 `foo` 函数：

```cpp
void foo(char*);  
void foo(int);
```

那么 `foo(NULL);` 这个语句将会去调用 `foo(int)`，从而导致代码违反直觉。

> [!NOTE]
> 这里的 `foo` 只是教科书里常用的**占位符函数名**，你可以把它理解为“某个函数”。

为了解决这个问题，C++11 引入了 `nullptr` 关键字，专门用来区分空指针、`0`。而 `nullptr` 的类型为 `nullptr_t`，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。

你可以尝试使用 `clang++` 编译下面的代码：

```cpp
#include <iostream>  
#include <type_traits>  
  
void foo(char *);  
void foo(int);  
  
int main() {  
    if (std::is_same<dec ltype(NULL), decltype(0)>::value)  
        std::cout << "NULL == 0" << std::endl;  
    if (std::is_same<decltype(NULL), decltype((void*)0)>::value)  
        std::cout << "NULL == (void *)0" << std::endl;  
    if (std::is_same<decltype(NULL), std::nullptr_t>::value)  
        std::cout << "NULL == nullptr" << std::endl;  
  
    foo(0);          // 调用 foo(int)  
    // foo(NULL);    // 该行不能通过编译  
    foo(nullptr);    // 调用 foo(char*)  
    return 0;  
}  
  
void foo(char *) {  
    std::cout << "foo(char*) is called" << std::endl;  
}  
void foo(int i) {  
    std::cout << "foo(int) is called" << std::endl;  
}
```

> [!NOTE]
> clang++编译命令：
> 
> clang++ -std=c++20 -Wall -Wextra -O2 main.cpp -o app
> 
> #### 参数拆解：
> 
> - **`-std=c++20`**：指定标准。你要习惯 C++20 的新特性，不要回退到过去。
>     
> - **`-Wall -Wextra`**：开启“严师模式”。它会捕捉到你代码中潜在的逻辑漏洞（比如变量定义了没用、函数没写返回值等）。
>     
> - **`-O2`**：优化级别。在 RK3588 这种 ARM 设备上跑 AI 模型，性能至关重要。
>     
> - **`-o app`**：指定输出文件名（Output）。
> 


将输出：

```cpp
foo(int) is called  
foo(char*) is called
```


从输出中我们可以看出，`NULL` 不同于 `0` 与 `nullptr`。所以，请养成直接使用 `nullptr`的习惯。

此外，在上面的代码中，我们使用了 `decltype` 和 `std::is_same` 这两个属于现代 C++ 的语法，简单来说，`decltype` 用于类型推导，而 `std::is_same` 用于比较两个类型是否相同，我们会在后面 [decltype](https://changkun.de/modern-cpp/zh-cn/02-usability/#decltype) 一节中详细讨论。


> [!NOTE]
> 对于看不懂的代码的部分笔记：
> ### 核心原理解析
> 
> #### 1. 底层视角 (The C Way)：类型丢失
> 
> 在 C 语言里，编译器不怎么关心 `0` 和 `(void*)0` 的区别，反正都是 64 位全零。但 C++ 是一门**强类型**语言，`int` 类型的 `0` 和指针类型的 `0` 在编译器眼里是完全不同的“生物”。
> 
> #### 2. 顶层视角 (The Python Way)：类型反射
> 
> 这就像 Python 里的 `type(obj) is int`。
> 
> - `decltype(x)`：就是“获取 x 的类型”。
>     
> - `std::is_same<T1, T2>::value`：就是“判断 T1 和 T2 是否是同一种类型”，返回 `true` 或 `false`。

> [!NOTE]
> 代码注解：
> ```cpp
> #include <iostream>
> #include <type_traits> // 必须包含这个头文件才能使用 std::is_same
> 
> int main() {
>     // 1. 检查 NULL 是否被定义为普通的整数 0
>     // decltype(NULL) 获取 NULL 的类型，decltype(0) 获取 0 的类型（即 int）
>     if (std::is_same<decltype(NULL), decltype(0)>::value) {
>         std::cout << "NULL == 0" << std::endl; 
>     }
> 
>     // 2. 检查 NULL 是否被定义为 C 风格的 (void*)0
>     // 在大部分 Modern C++ 编译器下，这一行通常为 false，因为 C++ 不允许 void* 隐式转指针
>     if (std::is_same<decltype(NULL), decltype((void*)0)>::value) {
>         std::cout << "NULL == (void *)0" << std::endl;
>     }
> 
>     // 3. 检查 NULL 是否被定义为 Modern C++ 的 nullptr_t 类型
>     // 只有极少数编译器为了兼容性会把 NULL 定义为 nullptr
>     if (std::is_same<decltype(NULL), std::nullptr_t>::value) {
>         std::cout << "NULL == nullptr" << std::endl;
>     }
> 
>     return 0;
> }
> ```



### constexpr

C++ 本身已经具备了常量表达式的概念，比如 `1+2`, `3*4` 这种表达式总是会产生相同的结果并且没有任何副作用。如果编译器能够在编译时就把这些表达式直接优化并植入到程序运行时，将能增加程序的性能。一个非常明显的例子就是在数组的定义阶段：

```cpp
#include <iostream>  
#define LEN 10  
  
int len_foo() {  
    int i = 2;  
    return i;  
}  
constexpr int len_foo_constexpr() {  
    return 5;  
}  
  
constexpr int fibonacci(const int n) {  
    return n == 1 || n == 2 ? 1 : fibonacci(n-1)+fibonacci(n-2);  
}  
  
int main() {  
    char arr_1[10];                      // 合法  
    char arr_2[LEN];                     // 合法  
  
    int len = 10;  
    // char arr_3[len];                  // 非法  
  
    const int len_2 = len + 1;  
    constexpr int len_2_constexpr = 1 + 2 + 3;  
    // char arr_4[len_2];                // 非法  
    char arr_4[len_2_constexpr];         // 合法  
  
    // char arr_5[len_foo()+5];          // 非法  
    char arr_6[len_foo_constexpr() + 1]; // 合法  
  
    std::cout << fibonacci(10) << std::endl;  
    // 1, 1, 2, 3, 5, 8, 13, 21, 34, 55  
    std::cout << fibonacci(10) << std::endl;  
    return 0;  
}
```

上面的例子中，`char arr_4[len_2]` 可能比较令人困惑，因为 `len_2` 已经被定义为了常量。为什么 `char arr_4[len_2]` 仍然是非法的呢？这是因为 C++ 标准中数组的长度必须是一个常量表达式，而对于 `len_2` 而言，这是一个 `const` 常数，而不是一个常量表达式，因此（即便这种行为在大部分编译器中都支持，但是）它是一个非法的行为，我们需要使用接下来即将介绍的 C++11 引入的 `constexpr` 特性来解决这个问题；而对于 `arr_5` 来说，C++98 之前的编译器无法得知 `len_foo()` 在运行期实际上是返回一个常数，这也就导致了非法的产生。


> 注意，现在大部分编译器其实都带有自身编译优化，很多非法行为在编译器优化的加持下会变得合法，若需重现编译报错的现象需要使用老版本的编译器。

C++11 提供了 `constexpr` 让用户显式的声明函数或对象构造函数在编译期会成为常量表达式，这个关键字明确的告诉编译器应该去验证 `len_foo` 在编译期就应该是一个常量表达式。


此外，constexpr 修饰的函数可以使用递归：
```cpp
constexpr int fibonacci(const int n) {
    return n == 1 || n == 2 ? 1 : fibonacci(n-1)+fibonacci(n-2);
}
```

从 C++14 开始，constexpr 函数可以在内部使用局部变量、循环和分支等简单语句，例如下面的代码在 C++11 的标准下是不能够通过编译的：
```cpp
constexpr int fibonacci(const int n) {
    if(n == 1) return 1;
    if(n == 2) return 1;
    return fibonacci(n-1) + fibonacci(n-2);
}
```

> [!NOTE]
> 为什么上面的代码在C++11编译不通过？
> **C++11 的限制**：当时的编译器开发者觉得，要在编译阶段模拟复杂的逻辑（如局部变量、多行分支）太难实现了。所以他们规定：`constexpr` 函数必须是**纯粹的表达式**。

为此，我们可以写出下面这类简化的版本来使得函数从 C++11 开始即可用：
```cpp
constexpr int fibonacci(const int n) {
    return n == 1 || n == 2 ? 1 : fibonacci(n-1) + fibonacci(n-2);
}
```



## 2.2 变量及其初始化


### if/switch 变量声明强化

在传统 C++ 中，变量的声明虽然能够位于任何位置，甚至于 `for` 语句内能够声明一个临时变量 `int`，但始终没有办法在 `if` 和 `switch` 语句中声明一个临时的变量。例如：

```cpp
#include <iostream>  
#include <vector>  
#include <algorithm>  
  
int main() {  
    std::vector<int> vec = {1, 2, 3, 4};  
  
    // 在 c++17 之前  
    const std::vector<int>::iterator itr = std::find(vec.begin(), vec.end(), 2);  
    if (itr != vec.end()) {  
        *itr = 3;  
    }  
  
    // 需要重新定义一个新的变量  
    const std::vector<int>::iterator itr2 = std::find(vec.begin(), vec.end(), 3);  
    if (itr2 != vec.end()) {  
        *itr2 = 4;  
    }  
  
    // 将输出 1, 4, 3, 4  
    for (std::vector<int>::iterator element = vec.begin(); element != vec.end();   
        ++element)  
        std::cout << *element << std::endl;  
}
```

在上面的代码中，我们可以看到 `itr` 这一变量是定义在整个 `main()` 的作用域内的，这导致当我们需要再次遍历整个 `std::vector` 时，需要重新命名另一个变量。C++17 消除了这一限制，使得我们可以在 `if`（或 `switch`）中完成这一操作：

```cpp
// 将临时变量放到 if 语句内  
if (const std::vector<int>::iterator itr = std::find(vec.begin(), vec.end(), 3);  
    itr != vec.end()) {  
    *itr = 4;  
}
```

怎么样，是不是和 Go 语言很像？

> [!NOTE]
> 人话：现代CPP可以在if、switch的括号中直接声明变量

### 初始化列表

初始化是一个非常重要的语言特性，最常见的就是在对象进行初始化时进行使用。 在传统 C++ 中，不同的对象有着不同的初始化方法，例如普通数组、 POD （**P**lain **O**ld **D**ata，即没有构造、析构和虚函数的类或结构体） 类型都可以使用 `{}` 进行初始化，也就是我们所说的初始化列表。 而对于类对象的初始化，要么需要通过拷贝构造、要么就需要使用 `()` 进行。 这些不同方法都针对各自对象，不能通用。例如：

```cpp
#include <iostream>  
#include <vector>  
  
class Foo {  
public:  
    int value_a;  
    int value_b;  
    Foo(int a, int b) : value_a(a), value_b(b) {}  
};  
  
int main() {  
    // before C++11  
    int arr[3] = {1, 2, 3};  
    Foo foo(1, 2);  
    std::vector<int> vec = {1, 2, 3, 4, 5};  
  
    std::cout << "arr[0]: " << arr[0] << std::endl;  
    std::cout << "foo:" << foo.value_a << ", " << foo.value_b << std::endl;  
    for (std::vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {  
        std::cout << *it << std::endl;  
    }  
    return 0;  
}
```

为解决这个问题，C++11 首先把初始化列表的概念绑定到类型上，称其为 `std::initializer_list`，允许构造函数或其他函数像参数一样使用初始化列表，这就为类对象的初始化与普通数组和 POD 的初始化方法提供了统一的桥梁，例如：

```cpp
#include <initializer_list>  
#include <vector>  
#include <iostream>  
  
class MagicFoo {  
public:  
    std::vector<int> vec;  
    MagicFoo(std::initializer_list<int> list) {  
        for (std::initializer_list<int>::iterator it = list.begin();  
             it != list.end(); ++it)  
            vec.push_back(*it);  
    }  
};  
int main() {  
    // after C++11  
    MagicFoo magicFoo = {1, 2, 3, 4, 5};  
  
    std::cout << "magicFoo: ";  
    for (std::vector<int>::iterator it = magicFoo.vec.begin();   
        it != magicFoo.vec.end(); ++it)   
        std::cout << *it << std::endl;  
}
```

这种构造函数被叫做初始化列表构造函数，具有这种构造函数的类型将在初始化时被特殊关照。

初始化列表除了用在对象构造上，还能将其作为普通函数的形参，例如：

```cpp
public:  
    void foo(std::initializer_list<int> list) {  
        for (std::initializer_list<int>::iterator it = list.begin();  
            it != list.end(); ++it) vec.push_back(*it);  
    }  
  
magicFoo.foo({6,7,8,9});
```

其次，C++11 还提供了统一的语法来初始化任意的对象，例如：

```cpp
Foo foo2 {3, 4};
```
### 结构化绑定

结构化绑定提供了类似其他语言中提供的多返回值的功能。在容器一章中，我们会学到 C++11 新增了 `std::tuple` 容器用于构造一个元组，进而囊括多个返回值。但缺陷是，C++11/14 并没有提供一种简单的方法直接从元组中拿到并定义元组中的元素，尽管我们可以使用 `std::tie` 对元组进行拆包，但我们依然必须非常清楚这个元组包含多少个对象，各个对象是什么类型，非常麻烦。

C++17 完善了这一设定，给出的结构化绑定可以让我们写出这样的代码：

```cpp
#include <iostream>  
#include <tuple>  
  
std::tuple<int, double, std::string> f() {  
    return std::make_tuple(1, 2.3, "456");  
}  
  
int main() {  
    auto [x, y, z] = f();  
    std::cout << x << ", " << y << ", " << z << std::endl;  
    return 0;  
}
```

关于 `auto` 类型推导会在 [auto 类型推导](https://changkun.de/modern-cpp/zh-cn/02-usability/#auto)一节中进行介绍。